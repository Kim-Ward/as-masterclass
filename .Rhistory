letters[1:4]
for (C in B:26){
if is_trigraph(A, B, C){
trigraphs <- trigraphs + 1
}
}
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == -1)
}
count_trigraphs <- function(){
#Counts the number of trigraphs in the Diana cryptosystem.
#The correct answer is 126.
trigraphs <- 0
for (A in 1:26){
for (B in A:26){
for (C in B:26){
if (is_trigraph(A, B, C)){
trigraphs <- trigraphs + 1
}
}
}
}
return(trigraphs)
}
count_trigraphs()
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == -25)
}
count_trigraphs
count_trigraphs()
is_trigraph(1, 2, 22)
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 25)
}
count_trigraphs()
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 0)
}
count_trigraphs()
26%%26
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 23)
}
count_trigraphs()
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 10)
}
count_trigraphs()
43 %% 10
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 10)
}
is_trigraph(1, 2, 7)
is_trigraph(5, 5, 26)
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 5)
}
count_trigraphs <- function(){
#Counts the number of trigraphs in the Diana cryptosystem.
#The correct answer is 126.
trigraphs <- 0
for (A in 1:26){
for (B in A:26){
for (C in B:26){
if (is_trigraph(A, B, C)){
trigraphs <- trigraphs + 1
}
}
}
}
return(trigraphs)
}
count_trigraphs()
count_trigraphs <- function(){
#Counts the number of trigraphs in the Diana cryptosystem.
#The correct answer is 126.
trigraphs <- 0
trigraph_list <- c()
for (A in 1:26){
for (B in A:26){
for (C in B:26){
if (is_trigraph(A, B, C)){
trigraphs <- trigraphs + 1
trigraph_list <- trigraph_list + c(A, B, C)
}
}
}
}
return(trigraph_list)
}
count_trigraphs()
count_trigraphs <- function(){
#Counts the number of trigraphs in the Diana cryptosystem.
#The correct answer is 126.
trigraphs <- 0
trigraph_list <- c()
for (A in 1:26){
for (B in A:26){
for (C in B:26){
if (is_trigraph(A, B, C)){
trigraphs <- trigraphs + 1
}
}
}
}
return(trigraph)
}
count_trigraphs()
count_trigraphs <- function(){
#Counts the number of trigraphs in the Diana cryptosystem.
#The correct answer is 126.
trigraphs <- 0
trigraph_list <- c()
for (A in 1:26){
for (B in A:26){
for (C in B:26){
if (is_trigraph(A, B, C)){
trigraphs <- trigraphs + 1
}
}
}
}
return(trigraphs)
}
count_trigraphs()
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 8)
}
count_trigraphs()
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return(A + B + C %% 26 == 28)
}
count_trigraphs <- function(){
#Counts the number of trigraphs in the Diana cryptosystem.
#The correct answer is 126.
trigraphs <- 0
trigraph_list <- c()
for (A in 1:26){
for (B in A:26){
for (C in B:26){
if (is_trigraph(A, B, C)){
trigraphs <- trigraphs + 1
}
}
}
}
return(trigraphs)
}
count_trigraphs()
is_trigraph(1,2, 25)
is_trigraph <- function(A, B, C){
#Tests if the triple (A, B, C) is a trigraph in the Diana cryptosystem.
return((A + B + C) %% 26 == 25)
}
count_trigraphs()
letter2num <- function(x) {utf8ToInt(x) - utf8ToInt("a") + 1}
letter2num("a")
letter2num("z")
letters
LETTERS
letter2num <- function(x) {utf8ToInt(x) - utf8ToInt("a") + 1}
trigraph_finder <- function(A, B){
#Finds the other letter making a trigraph with A and B.
A <- letter2num(A)
B <- letter2num(B)
C <- (1 - A - B) %% 26
C <- letters[C]
return(C)
}
trigraph_finder("s", "o")
trigraph_finder <- function(A, B){
#Finds the other letter making a trigraph with A and B.
A <- letter2num(A)
B <- letter2num(B)
C <- (-1 - A - B) %% 26
C <- letters[C]
return(C)
}
trigraph_finder("s", "o")
repeat_key <- function(key, length_to_repeat){
#Repeats a key to the desired length.
repeated_key <- ""
while (length_to_repeat > length(key)){
repeated_key <- paste(repeated_key, key)
length_to_repeat <- length_to_repeat - length(key)
}
repeated_key <- paste(repeated_key, substr(key, 1, length_to_repeat))
return(repeated_key)
}
repeat_key("cat", 15)
"cat" + "dog"
"cat"[2]
?sample
?paste
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:100000){
one_time_pad = paste(one_time_pad, letters(sample(i)), sep="")
}
return(one_time_pad)
}
generate_one_time_pad(1)
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:100000){
one_time_pad = paste(one_time_pad, letters[sample(i), sep="")
}
return(one_time_pad)
}
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:100000){
one_time_pad = paste(one_time_pad, letters[sample(i)], sep="")
}
return(one_time_pad)
}
generate_one_time_pad(1)
for (i in 1:10){
one_time_pad = paste(one_time_pad, letters[sample(i)], sep="")
}
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:10){
one_time_pad = paste(one_time_pad, letters[sample(i)], sep="")
}
return(one_time_pad)
}
#' 7) Why does this code run so slowly? Can you speed it up at all?
generate_one_time_pad(1)
?sample
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:10){
one_time_pad = paste(one_time_pad, letters[sample(26)], sep="")
}
return(one_time_pad)
}
generate_one_time_pad(1)
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:10){
one_time_pad = paste(one_time_pad, letters[sample(26, size=1)], sep="")
}
return(one_time_pad)
}
generate_one_time_pad(1)
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:100000){
one_time_pad = paste(one_time_pad, letters[sample(26, size=1)], sep="")
}
return(one_time_pad)
}
generate_one_time_pad(1)
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:10000){
one_time_pad = paste(one_time_pad, letters[sample(26, size=1)], sep="")
}
return(one_time_pad)
}
#' 7) Why does this code run so slowly? Can you speed it up at all?
generate_one_time_pad(1)
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad = ""
for (i in 1:100000){
one_time_pad = paste(one_time_pad, letters[sample(26, size=1)], sep="")
}
return(one_time_pad)
}
#' 7) Why does this code run so slowly? Can you speed it up at all?
generate_one_time_pad(1)
gho = "cat"
substr(gho, 2) = "d"
substr(gho, 2, 2) = "d"
gho
sink('hello.txt')
cat('hi')
sink()
?sink
?writeLines
c(4)
?readLines
as.numeric(Sys.time())
?substring
generate_one_time_pad <- function(seed){
#generates a one-time pad from a seed for a random number generator.
#obviously, they didn't have cheap random number generators lying around back when
#this cipher was used!
set.seed(seed)
one_time_pad <- ""
for (i in 1:100000){
one_time_pad <- paste(one_time_pad, letters[sample(26, size=1)], sep="")
}
return(one_time_pad)
}
otp = generate_one_time_pad(34)
tear_off_page <- function(one_time_pad){
#Destroys the first "page" (1000 letters) of the one-time pad.
one_time_pad <- substring(one_time_pad, 1000)
pages <- length(one_time_pad) / 1000
print("There are ", pages, " pages remaining.")
return()
}
tear_off_page((otp))
tear_off_page(otp)
tear_off_page <- function(one_time_pad){
#Destroys the first "page" (1000 letters) of the one-time pad.
one_time_pad <- substring(one_time_pad, 1000)
pages <- length(one_time_pad) / 1000
cat("There are ", pages, " pages remaining.")
return()
}
tear_off_page(otp)
length(otp)
otp
tear_off_page <- function(one_time_pad){
#Destroys the first "page" (1000 letters) of the one-time pad.
one_time_pad <- substring(one_time_pad, 1000)
pages <- nchar(one_time_pad) / 1000
cat("There are ", pages, " pages remaining.")
return()
}
length(otp)
tear_off_page(otp)
tear_off_page(otp)
repeat_key <- function(key, length_to_repeat){
#Repeats a key to the desired length.
repeated_key <- ""
while (length_to_repeat > length(key)){
repeated_key <- paste(repeated_key, key)
length_to_repeat <- length_to_repeat - length(key)
}
repeated_key <- paste(repeated_key, substr(key, 1, length_to_repeat))
return(repeated_key)
}
repeat_key("cat", 6)
tear_off_page <- function(one_time_pad){
#Destroys the first "page" (1000 letters) of the one-time pad.
one_time_pad <<- substring(one_time_pad, 1001)
pages <- nchar(one_time_pad) / 1000
cat("There are ", pages, " pages remaining.")
return()
}
tear_off_page(otp)
tear_off_page(otp)
tear_off_page <- function(one_time_pad){
#Destroys the first "page" (1000 letters) of the one-time pad.
one_time_pad <- substring(one_time_pad, 1001)
pages <- nchar(one_time_pad) / 1000
cat("There are ", pages, " pages remaining.")
return()
}
tear_off_page(otp)
tear_off_page(otp)
tear_off_page <- function(one_time_pad){
#Destroys the first "page" (1000 letters) of the one-time pad.
one_time_pad <- substring(one_time_pad, 1001)
pages <- nchar(one_time_pad) / 1000
cat("There are ", pages, " pages remaining.")
}
tear_off_page(otp)
library(devtools)
